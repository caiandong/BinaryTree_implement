# Tree
 c++实现的 二叉树，avl树，treap树，红黑树，暂时就这么多。以及一个命令行显示树结构的功能
 
 写完后发现写代码并不是原先想的那么单纯。
    我以为是经过困难重重的连续长时间才能完成的红黑树，却在一个我甚至都没想到写的下午写完了删除。
    事实上插入操作加上调试，修改工具显示节点颜色是花了好几天，但删除操作是半个小时内一气呵成，就改了几处(很大可能性有bug没发现)。
    
 第一次写了用来在命令行可视化二叉树的测试工具，老实说，这个工具写的太烂了，连好的想法都会被湮没的不知踪影。
 通过尽可能的用上c++的特性，模板，引用，函数符(对象)，原始指针等等，让我又加深认识到未来学习需要做笔记的道理的印象，
 这也是我强忍着一百个不情愿写下这些乱七八糟的一个原因。
 
 写代码不仅需要学习很多算法数据结构以及足够的代码量，它还有一个越写越发现的重要的问题:每一步抉择。
    这就是说，每次的技术选择或是算法选择决定后续的朝着烂代码发展的速度，也就是维护难度。这是一个重要的问题，也是一个好现象，
    只有在这个过程中保持每次选择的头脑清醒，才可使代码更加健壮一点，承受更多一点的工程复杂度，延长重构代码时刻的来临。
    自己需要保持敏感，才能在自身缺乏经验时，在开发项目初期尽早时刻，做出更好的选择。

这个过程非常难熬，多写代码会经历又一次以上的过程，这样可以让自己获得足够的经验，在面对不那么复杂的业务时能够消除此场景下的维护与重构，
使得再开发难度达到最小

后续会重新修改命令行树行结构的代码。
